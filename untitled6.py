# -*- coding: utf-8 -*-
"""Untitled6.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1sCt0CAa4h8AQ_WrSQXV-iVRiHKQ3nIe6
"""

import numpy as np
import matplotlib.pyplot as plt

# Update angle position and angular velocity
def update_angle(angvel,rad,dt):
  newrad=[]
  for i in range(len(angvel)):
    s=angvel[i]*dt+rad[i]
    newrad.append(s)
  return newrad

def update_vel(ref,u):
  newvel=[]
  for i in range(len(angvel)):
    s=ref[i]+u[i]
    newvel.append(s)
  return newvel

# To calculate the position of joint points(xp), points perpendicular to the offset(dp) and obstacle-xp
def update_pos(rad,L,x_ob,y_ob):

# Calculate the coordinates of each joint
    x1 = 0.0
    y1 = 0.0

    x2 = L[1]* np.cos(rad[:1])
    y2 = L[1]* np.sin(rad[:1])

    x3 = x2 + L[2] * np.cos(sum(rad[:2]))
    y3 = y2 + L[2] * np.sin(sum(rad[:2]))

    # x4 = x3 + L3 * np.cos(np.deg2rad(theta1 + theta2 + theta3))
    # y4 = y3 + L3 * np.sin(np.deg2rad(theta1 + theta2 + theta3))

    xp=[x1,x2,x3]
    yp=[y1,y2,y3]

    Xp=[x_ob-x1,x_ob-x2,x_ob-x3]
    Yp=[y_ob-y1,y_ob-y2,y_ob-y3]

    L_C=(x_ob*np.ones(3)-xp[:3])*np.cos([rad[0],sum(rad[:2]),sum(rad[:3])])+(y_ob*np.ones(3)-yp[:3])*np.sin([rad[0],sum(rad[:2]),sum(rad[:3])])

    L_D=np.ones(3)
    for i in range(3):
        if(L_C[i]<0):
            L_D[i]=0
        elif (L_C[i]<L[i]):
            L_D[i]=L_C[i]
        else:
            L_D[i]=L[i]

    X_D_1=[L_D[0]*np.cos(rad[0]),L_D[0]*np.sin(rad[0])]
    X_D_2=[xp[1]+L_D[1]*np.cos(sum(rad[:2])),yp[1]+L_D[1]*np.sin(sum(rad[:2]))]
    X_D_3=[xp[2]+L_D[2]*np.cos(sum(rad[:3])),yp[2]+L_D[2]*np.sin(sum(rad[:3]))]

    dp=[X_D_1,X_D_2,X_D_3]

    return(xp,yp,Xp,Yp,dp,L_D)

def update_dynamics_case_1(rad,L,angvel,n):
    #n is the joint number (first-index = 1)

    #For When L_Dn=0


    #If n==1 (base link)
    if n==1:
      f=np.array([0,0,0])
      g=np.array([0,0,1])

    #If n>=2 (all other joints)
    else:
      s0=0
      s1=0
      s2=0
      #j,angvel,rad,L are first-index = 0 hence the difference
      #sum(vec[:x+1]) gives the sum of the first x elements in the list
      # j in range(n-1) gives j=0 --- j=n-2
      for j in range(n-1):
        x=-L[j]*sum(angvel[:j+1])*np.sin(sum(rad[:j+1])) 
        """- added"""
        s0+=x
      for j in range(n-1):
        x=L[j]*sum(angvel[:j+1])*np.cos(sum(rad[:j+1]))
        s1+=x
      s2=sum(angvel[:n-1])
      
      f=np.array([s0,s1,s2])
      g=np.array([0,0,1])

    #f_1_X_D_2=np.asarray([-(L[0]*angvel[0]*np.sin(rad[0])),(L[0]*angvel[0]*np.cos(rad[0])),angvel[0]])
    #f_1_X_D_3=np.asarray([-(L[0]*angvel[0]*np.sin(rad[0])+L[1]*(sum(angvel[:2])*np.sin(sum(rad[:2])))),(L[0]*angvel[0]*np.cos(rad[0])+L[1]*(sum(angvel[:2]))*np.cos(sum(rad[:2]))),sum(angvel[:2])])
    #g(x) 
    #g_1_X_D_2=np.asarray([0,0,1])
    #g_1_X_D_3=np.asarray([0,0,1])
    #What?!--return(f_1_X_D_1,f_1_X_D_2,f_1_X_D_3,g_1_X_D_1,g_1_X_D_2,g_1_X_D_3)
    return(f,g)

def update_dynamics_case_2(rad,L,angvel,Xp,Yp,n):
    #n is the joint number (first-index = 1)

    #For When 0 < L_Dn < Ln
   
    x_1,x_2,x_3=Xp
    y_1,y_2,y_3=Yp

    #Xp,Yp are vectors of the distance of each link basepoint to the obstacle point

    def alpha1_n(n):
        def part1a(n):
            f=-(np.sin(sum(rad[:n]))**2)
            s=0
            for j in range(int(n)-1):
                x=L[j]*sum(angvel[:j+1])*np.sin(sum(rad[:j+1]))
                s+=x
            return(f*s)

        def part2a(n):
            f=-0.5*(np.sin(2*sum(rad[:n])))
            s=0
            for j in range(int(n-1)):
                x=L[j]*sum(angvel[:j+1])*np.cos(sum(rad[:j+1]))
                s+=x
            return(f*s)

        def part3a(n):
            f=sum(angvel[:n-1])
            s=Yp[n-1]*np.cos(2*sum(rad[:n]))-Xp[n-1]*np.sin(2*sum(rad[:n]))
            return(f*s)
        a=part1a(n)+part2a(n)+part3a(n)
        return(a)
   
    def beta1_n(n):
        def part1b(n):
            f=(np.cos(sum(rad[:n]))**2)
            s=0
            for j in range(int(n)-1):
                x=L[j]*sum(angvel[:j+1])*np.cos(sum(rad[:j+1]))
                s+=x
            return(f*s)

        def part2b(n):
            f= 0.5*(np.sin(2*sum(rad[:n])))
            s=0
            for j in range(int(n-1)):
                x=L[j]*sum(angvel[:j+1])*np.sin(sum(rad[:j+1]))
                s+=x
            return(f*s)

        def part3b(n):
            #Xp[n-1]=x_ob-xp[n-1], Yp[n-1]=y_ob-yp[n-1]
            f=sum(angvel[:n-1])
            s=Xp[n-1]*np.cos(2*sum(rad[:n]))+Yp[n-1]*np.sin(2*sum(rad[:n]))
            return(f*s)
        return(part1b(n)+part2b(n)+part3b(n))

    if n==1:
      #If n==1 (base link)
      f=np.array([0,0,0])
      g=np.array([Yp[n-1]*np.cos(2*rad[0])-Xp[n-1]*np.sin(2*rad[0]),Xp[n-1]*np.cos(2*rad[0])+Yp[n-1]*np.sin(2*rad[0]),1])

    else:
      #If n>=2 (all other links)
      f=np.array([alpha1_n(n),beta1_n(n),sum(angvel[:n-1])])
      g=np.array([Yp[n-1]*np.cos(2*(sum(rad[:n])))-Xp[n-1]*np.sin(2*(sum(rad[:n]))),Xp[n-1]*np.cos(2*(sum(rad[:n])))-Yp[n-1]*np.sin(2*(sum(rad[:n]))),1])

    # f_X_D_1=np.asarray([0,0,0])
    # f_X_D_2=np.asarray([alpha1_n(2),beta1_n(2),angvel[0]])
    # f_X_D_3=np.asarray([alpha1_n(3),beta1_n(3),sum(angvel[:2])])
    # #g(x) for the case-1 for each links 


    # g_X_D_2=np.asarray([y_2*np.cos(2*(sum(rad[:2])))-x_2*np.sin(2*(sum(rad[:2]))),x_2*np.cos(2*(sum(rad[:2])))-y_2*np.sin(2*(sum(rad[:2]))),1])
    # g_X_D_3=np.asarray([y_3*np.cos(2*(sum(rad[:3])))-x_3*np.sin(2*(sum(rad[:3]))),x_3*np.cos(2*(sum(rad[:3])))-y_3*np.sin(2*(sum(rad[:3]))),1])

    return(f,g)

def update_dynamics_case_3(rad,L,angvel,Xp,Yp,n):

    def alpha2_n(n):
        def part1a(n):
            s=0
            for j in range(n-1):
                x=L[j]*sum(angvel[:j+1])*np.sin(sum(rad[:j+1]))
                s+=x
            return(-1*s)

        def part2a(n):
            f=sum(angvel[:n-1])*L[n-1]*np.sin(sum(rad[:n]))
            return(-1*f)


        return(part1a(n)+part2a(n))

 
    def beta2_n(n):
        def part1b(n):
            s=0
            for j in range(n-1):
                x=L[j]*sum(angvel[:j+1])*np.cos(sum(rad[:j+1]))
                s+=x
            return(s)

        def part2b(n):
            f=sum(angvel[:n-1])*L[n-1]*np.cos(sum(rad[:n]))
            return(-1*f)


        return(part1b(n)+part2b(n))
    
    if n==1:
      #If n==1 (base link)
      f=np.array([0,0,0])
      g=np.array([-L[n-1]*np.sin(rad[n-1]),L[n-1]*np.cos(rad[n-1]),1])

    else:
      #If n>=2 (all other links)
      f=np.array([alpha2_n(n),beta2_n(n),sum(angvel[:n-1])])
      g=np.array([-L[n-1]*np.sin(sum(rad[:n])),L[n-1]*np.cos(sum(rad[:n])),1])

    # #f(x) for the case-1 for each links 
    # f_X_D_1=[alpha2_n(1),beta2_n(1),0]
    # f_X_D_2=[alpha2_n(2),beta2_n(2),angvel[0]]
    # f_X_D_3=[alpha2_n(3),beta2_n(2),sum(angvel[:0])]
    # #g(x) for the case-1 for each links
    # g_X_D_1=[-L[0]*np.sin(rad[0]),L[0]*np.cos(rad[0]),1]
    # g_X_D_2=[-L[1]*np.sin(sum(rad[:2])),L[1]*np.cos(sum(rad[:2])),1]
    # g_X_D_3=[-L[2]*np.sin(sum(rad[:3])),L[2]*np.cos(sum(rad[:3])),1]

    return(f,g)

#Finding gradient of the barrier function 
def control_assist(rad,angvel,l,x_ob,y_ob,dp,f,g,k,c,n):

# dp is the x and y position of point of interest on the link 
    X_D_n=dp[n-1]

    B_n=(1/((x_ob-X_D_n[0])**2+(y_ob-X_D_n[1])**2+(l[n-1])**2))+X_D_n[0]**2+X_D_n[1]**2+rad[n-1]**2


    grad_B_n=[((-2*(x_ob-X_D_n[0]))/((x_ob-X_D_n[0])**2+(y_ob-X_D_n[1])**2+l[n-1]**2)**2)+(2*X_D_n[0]),
    ((-2*(y_ob-X_D_n[1]))/((x_ob-X_D_n[0])**2+(y_ob-X_D_n[1])**2+l[n-1]**2)**2)+(2*X_D_n[1]),
    2*rad[n-1]]


    #Finding the control assist inputs J and I 

    I_n=np.array(grad_B_n)@np.array(f)+(np.array(grad_B_n)@np.array(g))*angvel[n-1]

    J_n=k*B_n+c


    if (I_n-J_n>0):
        u_n=-((I_n-J_n)/np.linalg.norm(np.array(grad_B_n)@g))*(np.array(grad_B_n)@g)
    else:
        u_n=0

    u_n=float(u_n)

    return(u_n)

def plot(xp,yp,dp,n,rad,L):
# Plot the robotic arm
    fig, ax = plt.subplots()
    c=['red','green','blue']
    x4 = xp[n-1] + L[n-1] * np.cos(sum(rad))
    y4 = yp[n-1] + L[n-1] * np.sin(sum(rad))
    xp.append(x4)
    yp.append(y4)
    ax.scatter(x_ob,y_ob)
    for i in range(n):
        ax.plot([xp[i], xp[i+1]], [yp[i], yp[i+1]], color=c[i], linewidth=2)
        ax.scatter(dp[i][0],dp[i][1], color=c[i])

    

    # Set axis limits and aspect ratio
    ax.set_xlim([-5.0, 5.0])
    ax.set_ylim([-5.0, 5.0])
    ax.set_aspect('equal')

    # Show the plot

###Begining of code

#initialisation
#initial angles
theta1 = 2.865
theta2 = 2.865
theta3 = 2.865
ang=[theta1,theta2,theta3]
rad=np.deg2rad(ang)
n=3
# n - number of the links


#initial angvel
theta_1_dot=0.1
theta_2_dot=0.2
theta_3_dot=0.3
angvel=[theta_1_dot,theta_2_dot,theta_3_dot]
ref=angvel
# Joint lengths
L1 = 1
L2 = 1
L3 = 1
L=[L1,L2,L3]

# robot arm width
l1=0.1
l2=0.1
l3=0.1
l=[l1,l2,l3]

#position of the obstacle
x_ob=1.0
y_ob=1.8



#CBF constants

k=[1,1,1]
c=[1,1,1]



end_time=10
dt=0.01
steps=int(end_time/dt)
joint_pos=[]
obs_perpen_pose=[]
trackerref=[]
trackeru=[]
trackervel=[]

for i in range(steps):
    xp,yp,Xp,Yp,dp,L_D=update_pos(rad,L,x_ob,y_ob) 
    # xp,yp - base joint position for each link
    # Xp,Yp - Xob-Xn 
    # dp -Xd,Yd
    f=[]
    g=[]
    u=[]
    for j in range(n):
        if (L_D[j]==0):
            f_,g_=update_dynamics_case_1(rad,L,angvel,j+1)
        elif (L_D[j]==L[j]):
            f_,g_=update_dynamics_case_3(rad,L,angvel,Xp,Yp,j+1)
        else:
            f_,g_=update_dynamics_case_2(rad,L,angvel,Xp,Yp,j+1)
        f.append(f_)
        g.append(g_)
    
    f=np.asarray(f)
    g=np.asarray(g)

    for w in range(n):
        u_=control_assist(rad,angvel,l,x_ob,y_ob,dp,f[w],g[w],k[w],c[w],w+1)
        u.append(u_)
    
    u=np.asarray(u)
    plot(xp,yp,dp,n,rad,L)
    rad=update_angle(angvel,rad,dt)
    angvel=update_vel(ref,u)

        # f_X_D_1,f_X_D_2,f_X_D_3,g_X_D_1,g_X_D_2,g_X_D_3=update_dynamics_case_2(rad,L,angvel,Xp,Yp)

        # f_X_D_1,f_X_D_2,f_X_D_3,g_X_D_1,g_X_D_2,g_X_D_3=update_dynamics_case_3(rad,L,angvel,Xp,Yp)
            # f_X_D_1,f_X_D_2,f_X_D_3,g_X_D_1,g_X_D_2,g_X_D_3=update_dynamics_case_1(rad,L,angvel)

def example():
    # Joint lengths
    L1 = 1
    L2 = 1
    L3 = 1
    L=[L1,L2,L3]
    x_ob=-.005
    y_ob=1.0
    
    # Joint angles (in degrees)
    theta1 = 45.0
    theta2 = 90.0
    theta3 = 45.0
    ang=[theta1,theta2,theta3]
    rad=np.deg2rad(ang)
    # Calculate the coordinates of each joint
    x1 = 0.0
    y1 = 0.0
    
    x2 = L1 * np.cos(np.deg2rad(theta1))
    y2 = L1 * np.sin(np.deg2rad(theta1))
    
    x3 = x2 + L2 * np.cos(np.deg2rad(theta1 + theta2))
    y3 = y2 + L2 * np.sin(np.deg2rad(theta1 + theta2))
    
    x4 = x3 + L3 * np.cos(np.deg2rad(theta1 + theta2 + theta3))
    y4 = y3 + L3 * np.sin(np.deg2rad(theta1 + theta2 + theta3))
    
    xp=[x1,x2,x3,x4]
    yp=[y1,y2,y3,y4]
    
    
    
    ## Calculate the length of Ld
    
    L_C=(x_ob*np.ones(3)-xp[:3])*np.cos([rad[0],sum(rad[:2]),sum(rad[:3])])+(y_ob*np.ones(3)-yp[:3])*np.sin([rad[0],sum(rad[:2]),sum(rad[:3])])
    
    L_D=np.ones(3)
    for i in range(3):
        if(L_C[i]<0):
            L_D[i]=0
        elif (L_C[i]<L[i]):
            L_D[i]=L_C[i]
        else:
            L_D[i]=L[i]
    
    
    ## Calculate x,y coords of D for each link
    
    X_D_1=[L_D[0]*np.cos(rad[0]),L_D[0]*np.sin(rad[0])]
    X_D_2=[xp[1]+L_D[1]*np.cos(sum(rad[:2])),yp[1]+L_D[1]*np.sin(sum(rad[:2]))]
    X_D_3=[xp[2]+L_D[2]*np.cos(sum(rad[:3])),yp[2]+L_D[2]*np.sin(sum(rad[:3]))]
    
    dp=[X_D_1,X_D_2,X_D_3]
    
    
    # Plot the robotic arm
    fig, ax = plt.subplots()
    ax.plot([x1, x2], [y1, y2], color='red', linewidth=2)
    ax.plot([x2, x3], [y2, y3], color='green', linewidth=2)
    ax.plot([x3, x4], [y3, y4], color='blue', linewidth=2)
    ax.scatter(x_ob,y_ob)
    ax.scatter(dp[0][0],dp[0][1], color="red")
    ax.scatter(dp[1][0],dp[1][1], color='green')
    ax.scatter(dp[2][0],dp[2][1], color='blue')
    
    # Set axis limits and aspect ratio
    ax.set_xlim([-5.0, 5.0])
    ax.set_ylim([-5.0, 5.0])
    ax.set_aspect('equal')
    
    # Show the plot
    plt.show()








def pygamedeal():

    import pygame
    import math
    
    # Pygame initialization
    pygame.init()
    width, height = 800, 600
    screen = pygame.display.set_mode((width, height))
    clock = pygame.time.Clock()
    
    # Define colors
    WHITE = (255, 255, 255)
    BLACK = (0, 0, 0)
    link_colors = [(255, 0, 0), (0, 255, 0), (0, 0, 255)]  # Example link colors
    
    # Define link lengths and initial rotation angles
    link_lengths = [100, 80, 60]
    rotations = [math.pi / 4, math.pi / 3, math.pi / 6]  # Example rotation angles
    
    # Define button properties
    button_width = 40
    button_height = 20
    button_margin = 10
    button_x = width - 2 * (button_width + button_margin)
    button_y = button_margin
    angular_velocity_button_rect = pygame.Rect(width - button_width - button_margin, height - button_height - button_margin,
                                               button_width, button_height)
    angular_velocity = 0.01  # Initial angular velocity
    
    # Function to handle button click event
    def handle_button_click(index, increment):
        rotations[index] += increment
    
    def handle_angular_velocity_button_click(increment):
        global angular_velocity
        angular_velocity += increment
    
    # Main game loop
    running = True
    while running:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if event.button == 1:  # Left mouse button clicked
                    mouse_pos = pygame.mouse.get_pos()
                    for i in range(len(rotations)):
                        positive_button_rect = pygame.Rect(button_x, button_y + (button_height + button_margin) * i,
                                                           button_width, button_height)
                        negative_button_rect = pygame.Rect(button_x + button_width + button_margin,
                                                           button_y + (button_height + button_margin) * i,
                                                           button_width, button_height)
                        if positive_button_rect.collidepoint(mouse_pos):
                            handle_button_click(i, math.pi / 12)  # Adjust the rotation angle by 15 degrees
                        elif negative_button_rect.collidepoint(mouse_pos):
                            handle_button_click(i, -math.pi / 12)  # Adjust the rotation angle by -15 degrees
                    if angular_velocity_button_rect.collidepoint(mouse_pos):
                        handle_angular_velocity_button_click(0.01)  # Increase angular velocity by 0.01
                    elif angular_velocity_button_rect.collidepoint(mouse_pos):
                        handle_angular_velocity_button_click(-0.01)  # Decrease angular velocity by 0.01
    
        # Update the rotation angles of the base joint and the angular velocity
        rotations[0] += angular_velocity
    
        # Clear the screen
        screen.fill(WHITE)
    
        # Draw the robotic arm
        start_pos = (width // 2, height // 2)
        end_pos = start_pos
        for i in range(len(link_lengths)):
            angle = sum(rotations[:i + 1])  # Cumulative angle up to this link
            dx = link_lengths[i] * math.cos(angle)
            dy = link_lengths[i] * math.sin(angle)
            end_pos = (int(end_pos[0] + dx), int(end_pos[1] + dy))
            pygame.draw.line(screen, link_colors[i], start_pos, end_pos, 3)
            start_pos = end_pos
    
        # Draw the buttons
        for i in range(len(rotations)):
            positive_button_rect = pygame.Rect(button_x, button_y + (button_height + button_margin) * i, button_width,
                                               button_height)
            pygame.draw.rect(screen, BLACK, positive_button_rect)
            font = pygame.font.Font(None, 16)
            text = font.render("+", True, WHITE)
            text_rect = text.get_rect(center=positive_button_rect.center)
            screen.blit(text, text_rect)
    
            negative_button_rect = pygame.Rect(button_x + button_width + button_margin,
                                               button_y + (button_height + button_margin) * i, button_width, button_height)
            pygame.draw.rect(screen, BLACK, negative_button_rect)
            text = font.render("-", True, WHITE)
            text_rect = text.get_rect(center=negative_button_rect.center)
            screen.blit(text, text_rect)
    
        # Draw the angular velocity buttons
        pygame.draw.rect(screen, BLACK, angular_velocity_button_rect)
        font = pygame.font.Font(None, 16)
        text = font.render("+", True, WHITE)
        text_rect = text.get_rect(center=angular_velocity_button_rect.center)
        screen.blit(text, text_rect)
    
        angular_velocity_button_rect2 = pygame.Rect(width - button_width - button_margin, height - 2 * (button_height + button_margin),
                                                    button_width, button_height)
        pygame.draw.rect(screen, BLACK, angular_velocity_button_rect2)
        text = font.render("-", True, WHITE)
        text_rect = text.get_rect(center=angular_velocity_button_rect2.center)
        screen.blit(text, text_rect)
    
        # Update the display
        pygame.display.flip()
        clock.tick(60)
    
    # Quit the game
    pygame.quit()